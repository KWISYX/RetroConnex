<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8" />
<title>Retro Connection Origin</title>
<style>
    body {
        background: linear-gradient(135deg, #222 70%, #4b2a09 100%);
        color: #efe1c6;
        font-family: 'VT323', monospace;
        margin: 0;
        display: flex;
        flex-direction: column;
        align-items: center;
        height: 100vh;
    }
    #dashboard {
        border: 2px solid #fff15f;
        border-collapse: collapse;
        width: 180px;
        font-size: 16px;
    }
    #dashboard th {
        background: #18190a;
        color: #fff15f;
        padding: 6px;
        border-bottom: 2px solid #b480ff
        text-align: center;
        font-size: 16px;
    }
    #dashboard td {
        background: #101010;
        color: #efe1c6;
        padding: 10px;
        text-align: center;
        border-bottom: 1px solid #333;
    }
    #container {
        display: flex;
        gap: 40px;
        margin-top: 30px;
        align-items: flex-start;
    }
    canvas {
        border: 7px solid #fff15f;
        background: #101010;
    }
    #sidebar {
        min-width: 180px;
        display: flex;
        flex-direction: column;
        align-items: flex-end;
    }
    #score, #coords, #timer {
        background: #18190a;
        border: 2px solid #fff15f;
        padding: 12px;
        margin-bottom: 15px;
        text-align: center;
        font-size: 24px;
        width: 160px;
        box-sizing: border-box;
    }
    #preview {
        margin: 10px 0;
        background: #18190a;
        margin-bottom: 30px;
        padding: 10px;
        width: 140px;
        height: 140px;
        display: flex;
        align-items: center;
        justify-content: center;
    }
    #preview-canvas {
        background: #282b18;
        image-rendering: pixelated;
        border: none;
    }
    #gameOver {
        display: none;
        position: absolute;
        z-index: 9;
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%);
        width: 380px;
        min-height: 110px;
        background: rgba(0, 0, 0, 0.93);
        color: #b480ff;
        font-size: 30px;
        font-family: inherit;
        text-align: center;
        border: 5px solid #b480ff;
        text-shadow: 0 0 8px #b480ff;
        border-radius: 10px;
        padding: 20px;
    }
    #replayBtn {
        font-family: inherit;
        margin-top: 14px;
        font-size: 20px;
        background: #b480ff;
        color: #000;
        border-radius: 6px;
        border: none;
        padding: 10px 35px;
        cursor: pointer;
        transition: background 0.2s;
    }
    #fragments {
        min-height: 64px;
        font-size: 20px;
        text-align: left;
    }
    .placeholder {
      color: #ffdf00;
      font-size: 1.2em;
    }
    .hidden-fragment {
        opacity: 0.12;
        filter: blur(0.5px);
    }
    .fragment {
        display: inline-block;
        margin-right: 4px;
        padding: 6px 4px;
        background: rgba(255,255,255,0.03);
        border-radius: 4px;
        color: #fff;
        letter-spacing: 1px;
    }
    .abyss-pulse {
    animation: abyssBreath 2.8s ease-in-out infinite;
    letter-spacing: 1px;
    }
    
    @keyframes abyssBreath {
        0%   { transform: scale(1); opacity: 0.85; }
        50%  { transform: scale(1.15); opacity: 1; text-shadow: 0 0 12px #000; }
        100% { transform: scale(1); opacity: 0.85; }
    }
    #replayBtn:hover { background: #d8b0ff; }
      * { image-rendering: pixelated; }
      h2 { font-size: 18px; font-family: inherit; color: #d8b0ff; margin-bottom: 8px; }

    .explode {
      animation: burst 600ms cubic-bezier(.2,.8,.2,1);
      transform-origin: center;
      text-shadow:
        0 0 2px rgba(255,140,0,0.9),
        0 0 8px rgba(255,140,0,0.65),
        0 0 14px rgba(255,200,80,0.35);
    }
    @keyframes burst {
      0%   { transform: scale(1); opacity: 1; filter: drop-shadow(0 0 0 rgba(0,0,0,0)); }
      30%  { transform: scale(1.25); opacity: 1; }
      100% { transform: scale(1); opacity: 1; }
    }

    @media (max-width: 720px){
      #container { flex-direction: column; align-items: center; gap: 12px; }
      #sidebar { align-items: center; min-width: unset; }
      #dashboard { width: 220px; }
      #score, #coords, #timer { width: 200px; }
    }
    .abyss-timer {
    font-size: 26px;
    color: #b480ff;
    letter-spacing: 2px;
    animation: abyssBreath 3s ease-in-out infinite;
    text-shadow: 0 0 6px #5c00ff;
    user-select: none;
    }
    
    /* Glitch rapide et sporadique */
    @keyframes abyssGlitch {
        0%   { transform: translate(0); opacity: 1; }
        8%   { transform: translate(-1px, 1px) skewX(6deg); opacity: 0.75; }
        10%  { transform: translate(1px, -1px) skewX(-6deg); opacity: 1; }
        12%  { transform: translate(0); opacity: 1; }
    }
    
    /* Distorsion rare (façon “léger tremblement cosmique”) */
    @keyframes abyssDistort {
        0% { filter: none; }
        94% { filter: none; }
        96% { filter: blur(1px) brightness(1.4); }
        100% { filter: none; }
    }

</style>
<link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
</head>
<body>
  <div id="container">
    <div>
      <canvas id="tetris" width="320" height="640" aria-label="Tetris board"></canvas>
      <div><center>And if you gaze long into an "abyss"... </br> the "abyss" also gazes into you.</center></div>
    </div>
    <!-- Sidebar -->
    <div id="sidebar">
      <table id="dashboard">
        <tr><th>SCORE</th></tr>
        <tr><td id="score">00000<br>LIGNES: 0<br>Niveau: 1</td></tr>
        <tr><th>TIMER</th></tr>
        <tr><td id="timer">02:00</td></tr>
        <tr><th>PREVIEW</th></tr>
        <tr><td><canvas id="preview-canvas" width="116" height="116"></canvas></td></tr>
        <tr><th>COORDINATES</th></tr>
        <tr><td id="coords" class="placeholder">✦</td></tr>
        <tr><th>INSTRUCTIONS</th></tr>
        <tr>
        <td id="instructions-sidebar">
          ← / → : Move</br>
          ↓ : Speed Up</br>
          ↑ or X : Rotate</br>
          Space Bar : Instant Drop</br>
          P : Pause</br>
      </td>
    </tr>
      </table>
    </div>
  </div>

  <div id="gameOver" role="dialog" aria-live="polite"></div>

<audio id="explosionSound" src="explosion.wav" preload="auto"></audio>
<audio id="victorySound" src="victory.wav" preload="auto"></audio>

<script>
/* --------- Helpers & DOM elements --------- */
const canvas = document.getElementById('tetris');
const ctx = canvas.getContext('2d');
const previewCanvas = document.getElementById('preview-canvas');
const previewCtx = previewCanvas.getContext('2d');
const fragmentsEl = document.getElementById('coords');
const explosionSound = document.getElementById('explosionSound');
const victorySound = document.getElementById('victorySound');

/* --------- Constants / shapes --------- */
const grid = 32, cols = 10, rows = 20;
const tetrominoes = {
    'I': [[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]],
    'O': [[1,1],[1,1]],
    'T': [[0,1,0],[1,1,1],[0,0,0]],
    'S': [[0,1,1],[1,1,0],[0,0,0]],
    'Z': [[1,1,0],[0,1,1],[0,0,0]],
    'J': [[1,0,0],[1,1,1],[0,0,0]],
    'L': [[0,0,1],[1,1,1],[0,0,0]]
};
const colors = { 'I':'#6fffff','O':'#ffff7e','T':'#ac60db','S':'#51f370','Z':'#ff634f','J':'#4f7aff','L':'#ffb252' };

/* --------- Game state --------- */
let playfield, tetromino, tetrominoRow, tetrominoCol, tetrominoName, nextTetromino;
let score, lines, speedLevel, dropInterval, lastDrop, paused, gameOver, revealedCoords;
let bag = [];
let abyssMode = false;

/* --------- Coordonnées (fausse & vraie) --------- */
function deobfuscate(text, shift = 17) {
    return text.split('').map(char => String.fromCharCode(char.charCodeAt(0) - shift)).join('');
}

// Fausse coordonnée (monde normal)
const fullCoordFake = deobfuscate("_EJÁGG?GGG1VAAGÁEJ?EJE"); 

// Vraie coordonnée (monde Abyss)
const fullCoordTrue = deobfuscate("bwrüxz~wxw6i|xxüwbr~wbw"); 

// Fragments utilisés selon le mode actif
let fullCoord = abyssMode ? fullCoordTrue : fullCoordFake;
const coordFragments = fullCoord.match(/.{1,3}/g) || [fullCoord];


/* --------- Timer --------- */
let countdownTime = 5 * 60 * 1000;
let timeRemaining = countdownTime;
let countdownInterval;
function updateCountdown(){
    if (abyssMode) return; //
    const totalSeconds = Math.floor(timeRemaining/1000);
    const m = String(Math.floor(totalSeconds/60)).padStart(2,'0');
    const s = String(totalSeconds % 60).padStart(2,'0');
    document.getElementById('timer').innerText = `${m}:${s}`;
}
function startCountdown(){
    if (abyssMode) return; //
    timeRemaining = countdownTime; updateCountdown();
    clearInterval(countdownInterval);
    countdownInterval = setInterval(()=>{
        if(paused || gameOver || abyssMode) return;
        timeRemaining -= 1000;
        if(timeRemaining <= 0){
            timeRemaining = 0; updateCountdown();
            clearInterval(countdownInterval);
            showTimeOver();
        } else updateCountdown();
    }, 1000);
}
function stopCountdown(){ clearInterval(countdownInterval); }
function resetCountdown(){ clearInterval(countdownInterval); timeRemaining = countdownTime; updateCountdown(); }

/* --------- UI helpers --------- */
function updateScore()
{
    // Mise à jour normale
    document.getElementById('score').innerHTML =
        `${String(score).padStart(5,'0')}<br>LIGNES: ${lines}<br>Niveau: ${speedLevel+1}`;

    // Mise à jour version Abyss
    updateAbyssInfoDisplay(score, lines, speedLevel + 1);

    // Détecte l’éventuel passage à l’Abyss
    checkAbyssTrigger();
}

/* Keep previous revealed count to detect increments and trigger animation */
let prevRevealed = 0;
function displayCoords(){
    if(revealedCoords === 0){
        // Pas de fragment → ✦
        fragmentsEl.classList.add('placeholder');
        fragmentsEl.textContent = '✦';
    } else {
        fragmentsEl.classList.remove('placeholder');
        let txt = '';
        for(let i=0; i<revealedCoords; i++) txt += coordFragments[i] || '';
        fragmentsEl.textContent = txt;
    }
    if(revealedCoords > prevRevealed){
        triggerFragmentBurst();
    }
    prevRevealed = revealedCoords;
    checkAbyssTrigger();
}


function triggerFragmentBurst(){
    try {
        explosionSound.currentTime = 0;
        explosionSound.play().catch(()=>{});
    } catch(e){}
    fragmentsEl.classList.add('explode');
    setTimeout(()=> fragmentsEl.classList.remove('explode'), 650);
}

/* --------- Drawing --------- */
function drawGrid(){
    ctx.strokeStyle = '#5a4633';
    ctx.lineWidth = 1;
    for(let i=0;i<=cols;i++){ ctx.beginPath(); ctx.moveTo(i*grid,0); ctx.lineTo(i*grid, canvas.height); ctx.stroke(); }
    for(let i=0;i<=rows;i++){ ctx.beginPath(); ctx.moveTo(0,i*grid); ctx.lineTo(canvas.width, i*grid); ctx.stroke(); }
}
function draw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    drawGrid();
    for(let r=0;r<rows;r++){
        for(let c=0;c<cols;c++){
            const cell = playfield[r][c];
            if(cell){
                // Si abyssMode = true, tout est mauve
                ctx.fillStyle = abyssMode ? "#b480ff" : (colors[cell] || '#888');
                ctx.fillRect(c*grid+2, r*grid+2, grid-4, grid-4);
            }
        }
    }
    if(tetromino && Array.isArray(tetromino)){
        for(let r=0;r<tetromino.length;r++){
            for(let c=0;c<tetromino[r].length;c++){
                if(tetromino[r][c]){
                    ctx.fillStyle = abyssMode ? "#b480ff" : (colors[tetrominoName] || '#fff');
                    ctx.fillRect((tetrominoCol+c)*grid+2, (tetrominoRow+r)*grid+2, grid-4, grid-4);
                }
            }
        }
    }
}
function drawPreview(){
    previewCtx.clearRect(0,0,previewCanvas.width, previewCanvas.height);
    if(!nextTetromino) return;
    const m = nextTetromino.matrix, name = nextTetromino.name;
    const bs = 24;
    const offsetX = Math.floor((previewCanvas.width - (m[0].length*bs))/2);
    const offsetY = Math.floor((previewCanvas.height - (m.length*bs))/2);
    previewCtx.fillStyle = abyssMode ? "#b480ff" : colors[name] || '#fff';
    for(let r=0;r<m.length;r++){
        for(let c=0;c<m[r].length;c++){
            if(m[r][c]) previewCtx.fillRect(offsetX + c*bs + 1, offsetY + r*bs + 1, bs-2, bs-2);
        }
    }
}

/* --------- Movement / rules --------- */
function isValidMove(matrix, row, col){
    for(let r=0;r<matrix.length;r++){
        for(let c=0;c<matrix[r].length;c++){
            if(matrix[r][c]){
                const y = row + r, x = col + c;
                if(x < 0 || x >= cols || y >= rows) return false;
                if(y >= 0 && playfield[y][x]) return false;
            }
        }
    }
    return true;
}
function merge(){
    let placedPiece = false;
    for(let r=0;r<tetromino.length;r++){
        for(let c=0;c<tetromino[r].length;c++){
            if(tetromino[r][c] && tetrominoRow + r >= 0){
                playfield[tetrominoRow + r][tetrominoCol + c] = tetrominoName;
                placedPiece = true;
            }
        }
    }
    let cleared = 0;
    for(let r=rows-1; r>=0; r--){
        if(playfield[r].every(v => v)){
            playfield.splice(r, 1);
            playfield.unshift(Array(cols).fill(0));
            r++;
            cleared++;
        }
    }
    if(cleared){
        score += cleared * 100;
        lines += cleared;
        if(lines >= (speedLevel + 1) * 5){
            speedLevel++;
            dropInterval = Math.max(120, dropInterval - 80);
            revealedCoords = Math.min(coordFragments.length, speedLevel + 1);
            displayCoords();
            if(revealedCoords >= coordFragments.length){ showVictory(); return; }
        }
        updateScore();
    }
    if(placedPiece){
        for(let r=0; r<1; r++){
            if(playfield[r].some(c => c !== 0)){ showGameOver(); return; }
        }
        startGame();
    }
}

    function updateTimer() { return; }

let abyssPulseInterval = null;

function startAbyssPulse() {
    const timerEl = document.getElementById("timer");
    if (!timerEl) return;

    // Effet permanent de respiration (CSS)
    timerEl.classList.add("abyss-pulse");

    abyssPulseInterval = setInterval(() => {
        if (!abyssMode) return; // sécurité

        const r = Math.random();

        // 10% — glitch violent
        if (r < 0.10) {
            timerEl.innerText = glitchText("ABYSS");
            return;
        }

        // 20% — lettres espacées / étirées
        if (r < 0.30) {
            timerEl.innerText = "A B Y S S";
            return;
        }

        // 20% — apparition de symboles occultes
        if (r < 0.50) {
            timerEl.innerText = "A҉B͞Y͡S̸S͘";
            return;
        }

        // 50% — état stable
        timerEl.innerText = "ABYSS";

    }, 700);
}

function glitchText(base) {
    const chars = "AБY$§5@#%ÆØΨλΔ※⟐⟊⟟";
    return base.split("").map(letter => {
        return Math.random() < 0.4 ? chars[Math.floor(Math.random()*chars.length)] : letter;
    }).join("");
}

let abyssFrame = 0;

function updateAbyssTimer() {
    const t = document.getElementById("timer");

    if (!abyssMode) return;

    // Base du texte
    let text = "ABYSS";

    // Variation respiratoire lente
    const pulse = Math.sin(abyssFrame / 28);
    let letters = text.split("");

    // Phase 1 : léger écartement des lettres
    if (pulse > 0.65) {
        letters = letters.join(" ").split("");
    }

    // Phase 2 : altérations ponctuelles
    if (pulse < -0.45) {
        letters = letters.map(l => {
            if (Math.random() < 0.15) {
                const glitches = ["͛","̷","̸","̶","̕","͘","̀","͂"];
                return l + glitches[Math.floor(Math.random()*glitches.length)];
            }
            return l;
        });
    }

    // Génération finale
    text = letters.join("");

    // Application
    t.innerHTML = text;
    t.classList.add("abyss-timer");

    // Glitch aléatoire (5% du temps)
    if (Math.random() < 0.05) {
        t.style.animation = "abyssGlitch 120ms ease";
        setTimeout(() => t.style.animation = "", 150);
    }

    // Distorsion cosmique (très rare)
    if (Math.random() < 0.01) {
        t.style.animation = "abyssDistort 300ms linear";
        setTimeout(() => t.style.animation = "", 300);
    }

    abyssFrame++;
}

    function glitchValue(realValue, intensity = 1) {
        if (!abyssMode) return realValue;
    
        // Grandes variations : valeurs incohérentes
        if (Math.random() < 0.15 * intensity) {
            return realValue + Math.floor(Math.random() * 200 - 100); 
        }
    
        // Valeurs totalement fausses
        if (Math.random() < 0.10 * intensity) {
            return Math.floor(Math.random() * 9999);
        }
    
        // Valeurs déformées
        if (Math.random() < 0.20 * intensity) {
            return realValue.toString().split("").reverse().join("");
        }
    
        // Parfois stable (pour donner du réalisme)
        return realValue;
    }
    
    function updateAbyssInfoDisplay(score, lines, level) {
        const scoreEl = document.getElementById("score");
    
        if (!abyssMode) {
            scoreEl.innerHTML =
                `${String(score).padStart(5,'0')}<br>LIGNES: ${lines}<br>Niveau: ${level}`;
            return;
        }
    
        const gScore = glitchValue(score, 1.3);
        const gLines = glitchValue(lines, 1.2);
        const gLevel = glitchValue(level, 1.4);
    
        scoreEl.innerHTML =
            `SCORE : ${gScore}<br>LINES : ${gLines}<br>SPEED : ${gLevel}`;
    
        // léger tremblement
        scoreEl.style.transform = `translate(${Math.random()*3-1.5}px, ${Math.random()*3-1.5}px)`;
        scoreEl.style.textShadow = `
            0 0 6px #b33fff,
            ${Math.random()*2}px ${Math.random()*2}px 2px #ff00ff
        `;
        setTimeout(() => scoreEl.style.transform = "none", 120);
    }



/* --------- Spawn, bag, reset --------- */
function getRandomTetromino(){
    if(bag.length === 0){
        bag = Object.keys(tetrominoes);
        for(let i=bag.length-1;i>0;i--){
            const j = Math.floor(Math.random()*(i+1));
            [bag[i], bag[j]] = [bag[j], bag[i]];
        }
    }
    const name = bag.pop();
    return { name, matrix: tetrominoes[name] };
}
function startGame(){
    tetromino = nextTetromino.matrix;
    tetrominoName = nextTetromino.name;
    nextTetromino = getRandomTetromino();
    tetrominoRow = -2;
    tetrominoCol = Math.floor((cols - tetromino[0].length)/2);
    if(!isValidMove(tetromino, tetrominoRow, tetrominoCol)){
        showGameOver();
        return;
    }
    drawPreview();
}
function resetGame(){
    playfield = Array.from({length: rows}, ()=> Array(cols).fill(0));
    score = 0; lines = 0; speedLevel = 0; dropInterval = 1000; lastDrop = Date.now();
    paused = false; gameOver = false; revealedCoords = 0; bag = [];
    nextTetromino = getRandomTetromino();
    updateScore(); displayCoords();
    document.getElementById('gameOver').style.display = 'none';
    startGame();
    resetCountdown(); startCountdown();
    requestAnimationFrame(update);
}

/* --------- Secret Mode : ABYSS --------- */
fullCoord = fullCoordFake;
let secretBuffer = '';

const secretCode = 'abyss';

document.addEventListener('keydown', e => {
  if (e.key.length === 1 && /^[a-zA-Z]$/.test(e.key)) {
    secretBuffer += e.key.toLowerCase();
    if (secretBuffer.endsWith(secretCode)) {
      activateAbyssMode();
    }
    if (secretBuffer.length > 10) secretBuffer = secretBuffer.slice(-10);
  }
});

/* Vérifie aussi le score exact */
function checkAbyssTrigger() {
  if (score === 1337 && !abyssMode) {
    activateAbyssMode();
    transformHUDToAbyss();
    startAbyssPulse();
    fullCoord = fullCoordTrue;
  }
}

/* À insérer dans updateScore() à la fin : checkAbyssTrigger(); */

  function activateAbyssMode() {
      abyssMode = true;
      
      const instr = document.getElementById("instructions-sidebar");
      instr.innerHTML = `
      ← / → : Drifting<br>
      ↓ : Descent<br>
      ↑ or X : Distort<br>
      Space : Collapse<br>
      P : Suspend<br><br>
      <span style="color:#b33fff; font-size:18px; text-shadow:0 0 6px #b33fff;">
      You should not be here...
      </span>
      `;
            // Message visuel
      const overlay = document.createElement('div');
      overlay.style.position = 'absolute';
      overlay.style.left = '50%';
      overlay.style.top = '50%';
      overlay.style.transform = 'translate(-50%, -50%)';
      overlay.style.color = '#b33fff';
      overlay.style.fontSize = '34px';
      overlay.style.fontFamily = 'VT323, monospace';
      overlay.style.textShadow = '0 0 6px #ff00ff, 0 0 14px #b33fff';
      overlay.style.zIndex = '99';
      overlay.innerText = 'A connection was successfully established with the Abyss...';
      document.body.appendChild(overlay);
  
      // Transition visuelle vers l’Abyss
      document.body.style.background = 'radial-gradient(circle at center, #060006 0%, #0a0012 40%, #000 100%)';
      document.querySelector('canvas').style.borderColor = '#b33fff';
      document.getElementById('dashboard').style.borderColor = '#b33fff';
      document.getElementById('score').style.borderColor = '#b33fff';
      document.getElementById('timer').style.borderColor = '#b33fff';
      document.getElementById('coords').style.borderColor = '#b33fff';
      document.querySelectorAll('th').forEach(th => th.style.color = '#b33fff');
  
      // Glitch périodique sur le body
      let glitchTimer = setInterval(() => {
          if (!abyssMode) { clearInterval(glitchTimer); return; }
          const hue = Math.floor(Math.random() * 360);
          document.body.style.filter = `hue-rotate(${hue}deg) contrast(1.2) brightness(1.05)`;
          setTimeout(() => document.body.style.filter = 'none', 150);
      }, 1200);
  
      // Glitch immédiat sur le timer
      updateAbyssTimer();
  
      // Message disparaît après quelques secondes
      setTimeout(() => overlay.remove(), 4000);
  
      fullCoord = fullCoordTrue;
      coordFragments = fullCoord.match(/.{1,3}/g);
      displayCoords();
  }


/* --------- Rotation / hard drop --------- */
function rotate(matrix){ return matrix[0].map((_,i)=>matrix.map(row=>row[i])).reverse(); }
function hardDrop(){ while(isValidMove(tetromino, tetrominoRow+1, tetrominoCol)) tetrominoRow++; merge(); draw(); }

/* --------- Explosions / Confettis (gameover/victory) --------- */
let particles = [];

function startExplosion(){ 
  explosionSound.currentTime = 0; explosionSound.play().catch(()=>{});
  particles = [];
  for(let r=0;r<rows;r++){
    for(let c=0;c<cols;c++){
      const cell = playfield[r][c];
      if(cell){
        for(let i=0;i<4;i++){
          particles.push({
            x: c*grid + grid/2,
            y: r*grid + grid/2,
            vx: (Math.random()-0.5)*6,
            vy: (Math.random()-1.2)*6,
            color: colors[cell],
            life: 80 + Math.random()*40,
            size: 2 + Math.random()*3
          });
        }
      }
    }
  }
  requestAnimationFrame(explosionLoop);
}

function startVictoryExplosion(){
  victorySound.currentTime = 0; victorySound.play().catch(()=>{});
  particles = [];
  for(let i=0; i<350; i++){
    particles.push({
      x: Math.random()*canvas.width,
      y: -20 - Math.random()*50,
      vx: (Math.random()-0.5)*2,
      vy: 2 + Math.random()*2,
      color: `hsl(${Math.random()*360},80%,60%)`,
      life: 200 + Math.random()*100,
      size: 3 + Math.random()*4
    });
  }
  requestAnimationFrame(explosionLoop);
}

function explosionLoop(){
  ctx.fillStyle = "rgba(0,0,0,0.25)";
  ctx.fillRect(0,0,canvas.width,canvas.height);

  particles.forEach(p=>{
    p.x += p.vx;
    p.y += p.vy;
    p.vy += 0.15;        
    p.life -= 2;
    ctx.fillStyle = p.color;
    ctx.fillRect(p.x, p.y, p.size, p.size);
  });

  particles = particles.filter(p=>p.life>0);
  if(particles.length>0) requestAnimationFrame(explosionLoop);
}

/* --------- Game Over / Victory / TimeOver --------- */
function showGameOver(){
    if(gameOver) return;
    gameOver = true;
    startExplosion();
    document.getElementById('gameOver').style.display = "block";
    document.getElementById('gameOver').innerHTML =
      `GAME OVER !<br><button id="replayBtn">Play Again?</button>`;
    document.getElementById('replayBtn').onclick = () => resetGame();
}

function showTimeOver(){
    if(gameOver) return;
    gameOver = true;
    startExplosion();
    document.getElementById('gameOver').style.display = "block";
    document.getElementById('gameOver').innerHTML =
      `Time is Over !<br><button id="replayBtn">Play Again?</button>`;
    document.getElementById('replayBtn').onclick = () => resetGame();
}

function showVictory(){
    if(gameOver) return;
    gameOver = true;
    startVictoryExplosion();
    document.getElementById('gameOver').style.display = "block";
    document.getElementById('gameOver').innerHTML =
      (abyssMode
        ? `HOORAY !<br>The real? coordinate is:<br>${fullCoordTrue}<br><button id="replayBtn">Play Again?</button>`
        : `HOORAY !<br>The real! coordinate is :<br>${fullCoordFake}<br><button id="replayBtn">Play Again?</button>`);
    document.getElementById('replayBtn').onclick = () => resetGame();
}

/* --------- Input --------- */
document.addEventListener('keydown', e=>{
    if(gameOver) return;
    if(e.key === 'p' || e.key === 'P'){ paused = !paused; if(!paused) requestAnimationFrame(update); return; }
    if(paused) return;
    if(!tetromino) return;

    if(e.key === 'ArrowLeft'){ if(isValidMove(tetromino, tetrominoRow, tetrominoCol-1)) tetrominoCol--; }
    else if(e.key === 'ArrowRight'){ if(isValidMove(tetromino, tetrominoRow, tetrominoCol+1)) tetrominoCol++; }
    else if(e.key === 'ArrowDown'){ if(isValidMove(tetromino, tetrominoRow+1, tetrominoCol)) tetrominoRow++; }
    else if(e.key === 'ArrowUp' || e.key.toLowerCase() === 'x'){
        const rotated = rotate(tetromino);
        if(isValidMove(rotated, tetrominoRow, tetrominoCol)) tetromino = rotated;
        else {
            for(let off of [-1,1,-2,2]){ if(isValidMove(rotated, tetrominoRow, tetrominoCol+off)){ tetromino = rotated; tetrominoCol += off; break; } }
        }
    } else if(e.code === 'Space'){ hardDrop(); }
    draw();
});

/* --------- Loop --------- */
  function update() {
      if (paused || gameOver) return;
  
      const now = Date.now();
      if (now - lastDrop > dropInterval) {
          if (isValidMove(tetromino, tetrominoRow + 1, tetrominoCol)) {
              tetrominoRow++;
          } else {
              merge();
          }
          lastDrop = now;
      }
  
      draw();
  
      // --------- Timer Abyss ---------
      if (abyssMode) {
          updateAbyssTimer();
      }
  
      requestAnimationFrame(update);
  }

/* --------- Init --------- */
resetGame();
</script>
</body>
</html>
